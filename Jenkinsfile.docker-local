pipeline {
    agent any
    
    environment {
        // Deployment configuration (local - no SSH needed)
        DEPLOY_PATH = '/opt/lab-numerator'
        
        // Docker configuration
        IMAGE_NAME = 'lab-numerator'
        IMAGE_TAG = "${env.BUILD_NUMBER}"
        CONTAINER_NAME = 'lab-numerator'
        
        APP_NAME = 'lab-numerator'
        BRANCH_NAME = "${env.GIT_BRANCH ?: 'main'}"
    }
    
    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 30, unit: 'MINUTES')
        disableConcurrentBuilds()
    }
    
    stages {
        stage('Checkout') {
            steps {
                echo 'üì¶ Checking out source code...'
                checkout scm
                
                script {
                    env.GIT_COMMIT_MSG = sh(
                        script: 'git log -1 --pretty=%B',
                        returnStdout: true
                    ).trim()
                    env.GIT_AUTHOR = sh(
                        script: 'git log -1 --pretty=%an',
                        returnStdout: true
                    ).trim()
                }
                
                echo "üìù Commit: ${env.GIT_COMMIT_MSG}"
                echo "üë§ Author: ${env.GIT_AUTHOR}"
            }
        }
        
        stage('Verify Docker') {
            steps {
                echo 'üê≥ Verifying Docker installation...'
                sh '''
                    docker --version
                    docker-compose --version
                    echo "‚úÖ Docker is available"
                '''
            }
        }
        
        stage('Prepare Deployment Directory') {
            steps {
                echo 'üîß Preparing deployment directory...'
                sh """
                    # Create deployment directory
                    sudo mkdir -p ${DEPLOY_PATH}
                    sudo chown \$(whoami):\$(whoami) ${DEPLOY_PATH} || true
                    
                    # Copy files to deployment directory
                    rsync -av --delete \
                        --exclude 'node_modules' \
                        --exclude '.git' \
                        --exclude '.next' \
                        --exclude 'logs' \
                        ${WORKSPACE}/ ${DEPLOY_PATH}/
                    
                    echo "‚úÖ Files copied to ${DEPLOY_PATH}"
                """
            }
        }
        
        stage('Build Docker Image') {
            steps {
                echo 'üê≥ Building Docker image...'
                sh """
                    cd ${DEPLOY_PATH}
                    
                    # Build Docker image
                    docker-compose build --no-cache
                    
                    # Tag with build number
                    docker tag ${IMAGE_NAME}:latest ${IMAGE_NAME}:${IMAGE_TAG}
                    
                    echo "‚úÖ Docker image built successfully"
                    docker images | grep ${IMAGE_NAME}
                """
            }
        }
        
        stage('Test SOAP Connectivity') {
            steps {
                echo 'üîå Testing SOAP service connectivity...'
                sh """
                    cd ${DEPLOY_PATH}
                    
                    # Test SOAP connectivity using a temporary container
                    docker run --rm --network host \
                        ${IMAGE_NAME}:latest \
                        node -e "
                            const axios = require('axios');
                            axios.get('http://ae89:8086', {timeout: 5000})
                                .then(() => console.log('‚úÖ SOAP endpoint reachable'))
                                .catch(e => console.log('‚ö†Ô∏è  SOAP test:', e.code));
                        " || echo "‚ö†Ô∏è  SOAP test failed (non-blocking)"
                """
            }
        }
        
        stage('Deploy') {
            when {
                branch 'main'
            }
            steps {
                echo 'üöÄ Deploying with Docker Compose...'
                sh """
                    cd ${DEPLOY_PATH}
                    
                    # Create .env file from .env.production if it doesn't exist
                    if [ ! -f .env ]; then
                        if [ -f .env.production ]; then
                            cp .env.production .env
                            echo "üìù Created .env file from .env.production"
                        else
                            echo "‚ö†Ô∏è  .env.production not found, creating default .env"
                            cat > .env << 'EOF'
SOAP_URL=http://ae89:8086/gxsalud/servlet/com.asesp.gxsalud.alabwbs01
USE_PRODUCTION_SOAP=true
SOAP_USERNAME=Totemlabo
SOAP_PASSWORD=T0temLab0
NODE_ENV=production
PORT=3000
EOF
                        fi
                    fi
                    
                    # Stop and remove old containers
                    docker-compose down || true
                    
                    # Start new containers
                    docker-compose up -d
                    
                    # Show status
                    docker-compose ps
                    
                    echo "‚úÖ Deployment completed"
                """
            }
        }
        
        stage('Health Check') {
            when {
                branch 'main'
            }
            steps {
                echo 'üè• Performing health check...'
                script {
                    sleep(time: 15, unit: 'SECONDS')
                    
                    sh """
                        cd ${DEPLOY_PATH}
                        
                        # Check container is running
                        if ! docker-compose ps | grep -q "Up"; then
                            echo "‚ùå Container is not running"
                            docker-compose logs --tail=50
                            exit 1
                        fi
                        
                        # Check HTTP endpoint
                        for i in {1..10}; do
                            if curl -sf http://localhost:3000 > /dev/null; then
                                echo "‚úÖ Health check passed!"
                                exit 0
                            fi
                            echo "Waiting for application to start... (\$i/10)"
                            sleep 3
                        done
                        
                        echo "‚ùå Health check failed after 30 seconds"
                        docker-compose logs --tail=50
                        exit 1
                    """
                }
            }
        }
        
        stage('Cleanup Old Images') {
            when {
                branch 'main'
            }
            steps {
                echo 'üßπ Cleaning up old Docker images...'
                sh """
                    # Keep only the last 3 tagged images
                    docker images ${IMAGE_NAME} --format "{{.Tag}}" | \
                        grep -E "^[0-9]+\$" | \
                        sort -rn | \
                        tail -n +4 | \
                        xargs -I {} docker rmi ${IMAGE_NAME}:{} || true
                    
                    # Remove dangling images
                    docker image prune -f || true
                    
                    echo "‚úÖ Cleanup completed"
                """
            }
        }
    }
    
    post {
        success {
            echo '‚úÖ Pipeline completed successfully!'
            
            script {
                if (env.BRANCH_NAME == 'main') {
                    echo """
                    üéâ Deployment Successful!
                    
                    Branch: ${env.BRANCH_NAME}
                    Commit: ${env.GIT_COMMIT_MSG}
                    Author: ${env.GIT_AUTHOR}
                    Build: #${env.BUILD_NUMBER}
                    Image: ${IMAGE_NAME}:${IMAGE_TAG}
                    
                    Access: http://localhost:3000
                    """
                }
            }
        }
        
        failure {
            echo '‚ùå Pipeline failed!'
            
            echo """
            ‚ö†Ô∏è  Deployment Failed!
            
            Branch: ${env.BRANCH_NAME}
            Commit: ${env.GIT_COMMIT_MSG}
            Build: #${env.BUILD_NUMBER}
            
            Check console output for details.
            """
        }
        
        always {
            echo 'üßπ Pipeline completed'
        }
    }
}

